## 浏览器原理

> 对于前端开发来说，接触最多的就是浏览器了，我们需要学习一下浏览器的原理，有助于我们更好地理解web应用，以及如何提高和优化web的性能，在遇到问题时候可以及时定位到问题。

当我们打开一个页面，打开chrome浏览器的**更多工具 ->  任务管理器**，我们会发现有多个**进程**。

首先先来粗略地总结一下进程和线程的区别：

#### 1. 线程 VS 进程

**① 一个进程就是一个程序运行的实例**

比如，我们启动一个程序的时候，操作系统就会为该程序分配内存空间，用来存放该程序的代码，数据，文件和执行任务的线程。这种运行环境成为进程。

**② 一个进程可以运行多个线程**

当一个进程中只有一个执行任务的主线程，则成为单线程，如果有多个线程，则成为多线程，

**③进程中一旦有一个线程执行出错，会导致整个进程崩溃**

**④ 线程之间共享进程的数据，但是进程之间的内容是相互隔离的，毫无关系。**

**⑤当一个进程关闭之后，操作系统会回收进程所占用的内存空间**

#### 2. 早期 vs 现代的浏览器

早期的浏览器是单进程的，所有的模块都运行到同一个进程中，这样会导致很多的问题：

- 不稳定

插件容易导致浏览器崩溃

- 不流畅

当js运行的代码，阻塞了页面，比如遇到了死循环，由于在同一个进程，容易导致失去响应；

页面存在内存泄露的可能，使内存占用变高，导致卡顿。

- 不安全

页面运行的插件，可以获取操作系统的任意资源，如果是恶意的插件，则有可能放出病毒，盗取账号密码等。

现代的浏览器是多进程的，一个页面就是进程，不同站点的不同页面的数据是分隔开的；根剧之前早期的缺陷来看看是如何解决的：

当页面崩溃时影响的只是当前的进程，不会导致整个浏览器崩溃；

js是运行在渲染进程中，所以只会影响到当前的进程，不会影响其他页面；当关闭一个页面时候，整个渲染进程也会被关闭，占用的内存会被系统回收，就不存在内存泄露的问题。

对于安全问题，多进程可以使用安全沙箱，把插件进程和渲染进程锁在沙箱中，不允许访问涉及安全问题的位置。

#### 3. 多进程浏览器

最新的chrome浏览器包括：

- 浏览器主进程

  负责界面显示，用户交互，管理子进程，管理存储；

- 渲染进程

  负责将HTML，CSS，JS转化为用户可交互的页面，排版引擎blink和v8引擎都是运行在该进程中的，每创建一个tab标签就会创建一个渲染进程；

- GPU进程

  最早用于3D CSS效果，后来UI界面和网页都采用GPU绘画，就成为一个必须的进程；

- 网络进程

  负责加载网络资源

- 插件进程

  负责插件的运行

衡量web页面性能的一个指标是FP，即从页面加载到首次绘制的时长，影响这个指标最重要的因素是网络加载速度，我们需要了解TCP/IP协议，众所周知，两方要通信，则必须要建立起同一的标准和规则，协议就这么来了。

这边简单描述一下是如何通信的：

#### 4. TCP/IP 通信

发送端在应用层中生成http报文数据，传送到传输层，传输层则会在报文头部加入TCP首部，再传送到网络层，加上远程服务器的地址和源地址的IP，即IP头，再经过数据链路层，加入以太网首部，接收端则会一步步解析，最终解析出客户端的请求内容。

**TCP特点：**

- 对于数据包丢失，提供重传机制
- 引入数据包排序机制，将大文件分割成许多小文件，最后根据序号组成一个大文件

http协议是建立在TCP连接的基础上，通常是由浏览器发起的请求，当我们在浏览器输入一个地址到一个页面渲染完成，究竟发生了什么呢？

#### 5. 浏览器端HTTP 请求流程

当我们在浏览器的地址栏输入一个页面的地址时

**①首先是请求行**，例如：

```
GET /test.html HTTP1.1
```

**②再查找缓存**

如果请求的页面存在于浏览器的缓存中，则不需要发起真正的请求，这样做的好处是可以减轻服务端的压力，使加载速度更快。如果缓存中没有，则继续

**③获取IP和端口号**

我们知道要请求一个页面的资源，必须要知道这个资源所在的IP，端口号，和对应的文件目录等等。浏览器会根据输入的域名，请求DNS返回域名对应的IP，如果某个域名曾经解析过，则可以直接从DNS数据缓存中取数据，而不用再次去请求，端口号可以从url中获取或者默认的80端口。

**HTTP和TCP的关系：**
HTTP的内容是通过TCP传输数据来实现的，所以，http网络请求的第一步就是和TCP建立连接。

**④建立连接**

**chrome机制规定同一个域名同时最多只能建立6个TCP连接**，需要排队等待，所以当IP和端口都准备好了，不一定马上就可以建立连接。建立TCP连接需要经过三次握手，详细的就不再说明了，建立完后之后，浏览器就可以换和服务器进行通信了。

**⑤发送数据**

通过TCP数据传输，将http请求行发送到服务器端，如果是POST方法，则需要加上请求体，一般是一些参数数据。请求行发送之后，还要发送请求体，主要包括浏览器的基础信息，比如内核，操作系统，浏览器内核，cookie或者token等等。

**⑥返回数据**

服务器解析数据包之后，返回响应行（HTTP/1.1 200 ok），响应头和响应体。响应行中带有协议版本，状态码。

**⑦断开和完成**

当客户端收到了响应信息，就要关闭TCP连接，如果浏览器在请求头中加入**Connect: keep-alive**则会保持连接装填，可以节省下次连接建立需要的事件，提升加载速度。

到目前为止，一次http请求就算完成啦！

但是有个问题，就是当第一次请求时候比较缓慢 ，第二次再请求时候速度就变快了很多。这是为啥呢？那就要来看看浏览器的缓存机制了

#### 6. 浏览器中页面缓存

从以上的分析，我们可以知道缓存主要是DNS缓存和页面资源的缓存

- DNS缓存

  浏览器本地把对应的IP和域名关联起来

- 页面资源缓存

  当浏览器第一次发起http请求，并在请求头中的Cache-control设置max-age即缓存过期时，

  ```
  Cache-Control:Max-age=2000
  ```

  第一次请求缓存是空的，就直接访问服务器，然后缓存到本地，当再次请求时，会判断是否在缓存期内，如果在则直接返回本地缓存，如果超过缓存期，会继续发起网络请求，并在请求头中带上：

  ```
  If-None-Match:"xxx"
  ```

  服务器会根据这个值来判断请求的资源是否有更新，如果没有更新，则告诉浏览器当前的缓存可以用，返回304，否则就直接返回最新的资源

#### 7. cookie和token

在实际的业务场景中，我们访问网页，需要保存用户的登录状态，除非用户主动退出，那么浏览器是怎么做到的呢？主要有两种技术：

- cookie

  当用户输入账号密码登录时候，服务器会验证账号密码，成功则在响应头中加上：

  ```
  Set-Cookie: UTD=xxx
  ```

  浏览器在收到响应头时，会解析响应头，发现含有Set-cookie，则会把这个属性对应的值保存到本地，再下次请求时候，会把这个值写到请求头的Cookie里

  ```
  Cookie: UTD=xxx
  ```

  服务器收到这个字段时，回去session表中查找对应的cookie值(sessionID)，并找到用户的登录的状态，并识别身份，再将生成的数据发送给浏览器。当用户登出，session在客户端和服务器端都会被销毁。

- token

  当用户输入账号密码登录时候，服务器会生成token，并返回给客户端，客户端需要在下次请求时请求头中带上：

  ```
  Authorization header: Bear xxxxx;
  ```

  服务端根据对应的token就可以获取用户的信息。

**区别：**

cookie的验证是有状态的，绘画需要一直在服务端和客户端保持，一旦登出，则全部销毁；

token的验证是无状态的，token存储在客户端，在请求时候根据约定，放在Authorization header，服务端只需要验证token是否有效，不需要验证是否是登录状态，一旦登出，token在客户端可以销毁，但是不影响服务端。

但是现在普遍是使用token而不用cookie，优势在于：

①后端不需要保持对token的记录，cookie则需要，每个token都是独立的，只需要验证有效性，提高了效率

②token的CORS可以很好地解决跨域问题















